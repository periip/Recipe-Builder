"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/chef/page",{

/***/ "(app-pages-browser)/./src/app/api/scripts.js":
/*!********************************!*\
  !*** ./src/app/api/scripts.js ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkDbConnection: () => (/* binding */ checkDbConnection),\n/* harmony export */   countTable: () => (/* binding */ countTable),\n/* harmony export */   fetchAndDisplayUsers: () => (/* binding */ fetchAndDisplayUsers),\n/* harmony export */   fetchTableData: () => (/* binding */ fetchTableData),\n/* harmony export */   insertCheftable: () => (/* binding */ insertCheftable),\n/* harmony export */   resetTable: () => (/* binding */ resetTable)\n/* harmony export */ });\n/*\r\n * These functions below are for various webpage functionalities. \r\n * Each function serves to process data on the frontend:\r\n *      - Before sending requests to the backend.\r\n *      - After receiving responses from the backend.\r\n * \r\n * To tailor them to your specific needs,\r\n * adjust or expand these functions to match both your \r\n *   backend endpoints \r\n * and \r\n *   HTML structure.\r\n * \r\n */ // This function checks the database connection and updates its status on the frontend.\nasync function checkDbConnection() {\n    const statusElem = document.getElementById('dbStatus');\n    const loadingGifElem = document.getElementById('loadingGif');\n    const response = await fetch('/api/controller?action=check-db-connection', {\n        method: \"GET\"\n    });\n    // Hide the loading GIF once the response is received.\n    loadingGifElem.style.display = 'none';\n    // Display the statusElem's text in the placeholder.\n    statusElem.style.display = 'inline';\n    response.json().then((res)=>{\n        statusElem.textContent = \" \" + res.message;\n    }).catch((error)=>{\n        statusElem.textContent = 'connection timed out'; // Adjust error handling if required.\n    });\n}\n// Fetches data from the demotable and displays it.\nasync function fetchAndDisplayUsers(name) {\n    const tableElement = document.getElementById('Cheftable');\n    const tableBody = tableElement.querySelector('tbody');\n    const response = await fetch(\"/api/controller?action=table&name=\".concat(name), {\n        method: 'GET'\n    });\n    const responseData = await response.json();\n    const demotableContent = responseData.data;\n    // Always clear old, already fetched data before new fetching process.\n    if (tableBody) {\n        tableBody.innerHTML = '';\n    }\n    demotableContent.forEach((user)=>{\n        const row = tableBody.insertRow();\n        user.forEach((field, index)=>{\n            const cell = row.insertCell(index);\n            cell.textContent = field;\n        });\n    });\n}\n// This function resets or initializes the demotable.\nasync function resetTable(name) {\n    const response = await fetch(\"/api/controller?action=initiate-table&name=\".concat(name), {\n        method: 'POST'\n    });\n    const responseData = await response.json();\n    if (responseData.success) {\n        const messageElement = document.getElementById('resetResultMsg');\n        messageElement.textContent = \"Cheftable initiated successfully!\";\n        fetchTableData();\n    } else {\n        alert(\"Error initiating table!\");\n    }\n}\n// Inserts new records into the demotable.\nasync function insertCheftable(event, name) {\n    event.preventDefault();\n    const nameValue = event.target.elements[0].value;\n    const YOEValue = event.target.elements[1].value;\n    const seniorityValue = event.target.elements[2].value;\n    const licenseValue = event.target.elements[3].value;\n    const response = await fetch(\"/api/controller?action=insert-table&name=\".concat(name), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            chef_name: nameValue,\n            years_of_experience: YOEValue,\n            seniority: seniorityValue,\n            cooking_license: licenseValue\n        })\n    });\n    const responseData = await response.json();\n    responseHandler(responseData, 'insertResultMsg', name, \"Data inserted successfully!\");\n}\n// Counts rows in the demotable.\n// Modify the function accordingly if using different aggregate functions or procedures.\nasync function countTable(name) {\n    const response = await fetch(\"/api/controller?action=count-table&name=\".concat(name), {\n        method: 'GET'\n    });\n    const responseData = await response.json();\n    const messageElement = document.getElementById('countResultMsg');\n    if (responseData.success) {\n        const tupleCount = responseData.count;\n        messageElement.textContent = \"The number of tuples in demotable: \".concat(tupleCount);\n    } else {\n        alert(\"Error in count demotable!\");\n    }\n}\n// Updates names in the recipe table.\nasync function updateNameRecipetable(event, name) {\n    event.preventDefault();\n    const oldNameValue = document.getElementById('updateOldName').value;\n    const newNameValue = document.getElementById('updateNewName').value;\n    const response = await fetch('/update-name-recipetable', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            oldName: oldNameValue,\n            newName: newNameValue\n        })\n    });\n    const responseData = await response.json();\n    responseHandler(responseData, 'updateResultMsg', name, \"Name updated successfully!\", \"Error updating name!\");\n}\nfunction responseHandler(data, id, name, message, errMessage) {\n    const messageElement = document.getElementById(id);\n    if (data.success) {\n        data.textContent = message;\n        fetchTableData(name);\n    } else {\n        messageElement.textContent = errMessage;\n    }\n}\n// General function to refresh the displayed table data. \n// You can invoke this after any table-modifying operation to keep consistency.\nfunction fetchTableData(name) {\n    fetchAndDisplayUsers(name);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvYXBpL3NjcmlwdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7OztDQVlDLEdBR0QsdUZBQXVGO0FBQ2hGLGVBQWVBO0lBQ2xCLE1BQU1DLGFBQWFDLFNBQVNDLGNBQWMsQ0FBQztJQUMzQyxNQUFNQyxpQkFBaUJGLFNBQVNDLGNBQWMsQ0FBQztJQUUvQyxNQUFNRSxXQUFXLE1BQU1DLE1BQU0sOENBQThDO1FBQ3ZFQyxRQUFRO0lBQ1o7SUFDQSxzREFBc0Q7SUFDdERILGVBQWVJLEtBQUssQ0FBQ0MsT0FBTyxHQUFHO0lBQy9CLG9EQUFvRDtJQUNwRFIsV0FBV08sS0FBSyxDQUFDQyxPQUFPLEdBQUc7SUFFM0JKLFNBQVNLLElBQUksR0FDUkMsSUFBSSxDQUFDLENBQUNDO1FBQ0hYLFdBQVdZLFdBQVcsR0FBRyxNQUFNRCxJQUFJRSxPQUFPO0lBQzlDLEdBQ0NDLEtBQUssQ0FBQyxDQUFDQztRQUNKZixXQUFXWSxXQUFXLEdBQUcsd0JBQXlCLHFDQUFxQztJQUMzRjtBQUNSO0FBRUEsbURBQW1EO0FBQzVDLGVBQWVJLHFCQUFxQkMsSUFBSTtJQUMzQyxNQUFNQyxlQUFlakIsU0FBU0MsY0FBYyxDQUFDO0lBQzdDLE1BQU1pQixZQUFZRCxhQUFhRSxhQUFhLENBQUM7SUFFN0MsTUFBTWhCLFdBQVcsTUFBTUMsTUFBTSxxQ0FBMEMsT0FBTFksT0FBUTtRQUN0RVgsUUFBUTtJQUNaO0lBRUEsTUFBTWUsZUFBZSxNQUFNakIsU0FBU0ssSUFBSTtJQUN4QyxNQUFNYSxtQkFBbUJELGFBQWFFLElBQUk7SUFFMUMsc0VBQXNFO0lBQ3RFLElBQUlKLFdBQVc7UUFDWEEsVUFBVUssU0FBUyxHQUFHO0lBQzFCO0lBRUFGLGlCQUFpQkcsT0FBTyxDQUFDQyxDQUFBQTtRQUNyQixNQUFNQyxNQUFNUixVQUFVUyxTQUFTO1FBQy9CRixLQUFLRCxPQUFPLENBQUMsQ0FBQ0ksT0FBT0M7WUFDakIsTUFB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T0FBTztRQUNIa0IsZUFBZXZCLFdBQVcsR0FBR3NEO0lBQ2pDO0FBQ0o7QUFFQSx5REFBeUQ7QUFDekQsK0VBQStFO0FBQ3hFLFNBQVM5QixlQUFlbkIsSUFBSTtJQUMvQkQscUJBQXFCQztBQUN6QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxwZXJyeVxcT25lRHJpdmVcXERlc2t0b3BcXENvbGxlZ2VcXFllYXIgM1xcVDJcXENQU0MgMzA0XFxwcm9qZWN0X2o0bTFuX24wdDF2X3Y3bDl0LW1haW5cXHNyY1xcYXBwXFxhcGlcXHNjcmlwdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogVGhlc2UgZnVuY3Rpb25zIGJlbG93IGFyZSBmb3IgdmFyaW91cyB3ZWJwYWdlIGZ1bmN0aW9uYWxpdGllcy4gXHJcbiAqIEVhY2ggZnVuY3Rpb24gc2VydmVzIHRvIHByb2Nlc3MgZGF0YSBvbiB0aGUgZnJvbnRlbmQ6XHJcbiAqICAgICAgLSBCZWZvcmUgc2VuZGluZyByZXF1ZXN0cyB0byB0aGUgYmFja2VuZC5cclxuICogICAgICAtIEFmdGVyIHJlY2VpdmluZyByZXNwb25zZXMgZnJvbSB0aGUgYmFja2VuZC5cclxuICogXHJcbiAqIFRvIHRhaWxvciB0aGVtIHRvIHlvdXIgc3BlY2lmaWMgbmVlZHMsXHJcbiAqIGFkanVzdCBvciBleHBhbmQgdGhlc2UgZnVuY3Rpb25zIHRvIG1hdGNoIGJvdGggeW91ciBcclxuICogICBiYWNrZW5kIGVuZHBvaW50cyBcclxuICogYW5kIFxyXG4gKiAgIEhUTUwgc3RydWN0dXJlLlxyXG4gKiBcclxuICovXHJcblxyXG5cclxuLy8gVGhpcyBmdW5jdGlvbiBjaGVja3MgdGhlIGRhdGFiYXNlIGNvbm5lY3Rpb24gYW5kIHVwZGF0ZXMgaXRzIHN0YXR1cyBvbiB0aGUgZnJvbnRlbmQuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja0RiQ29ubmVjdGlvbigpIHtcclxuICAgIGNvbnN0IHN0YXR1c0VsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGJTdGF0dXMnKTtcclxuICAgIGNvbnN0IGxvYWRpbmdHaWZFbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvYWRpbmdHaWYnKTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2NvbnRyb2xsZXI/YWN0aW9uPWNoZWNrLWRiLWNvbm5lY3Rpb24nLCB7XHJcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiXHJcbiAgICB9KTtcclxuICAgIC8vIEhpZGUgdGhlIGxvYWRpbmcgR0lGIG9uY2UgdGhlIHJlc3BvbnNlIGlzIHJlY2VpdmVkLlxyXG4gICAgbG9hZGluZ0dpZkVsZW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIC8vIERpc3BsYXkgdGhlIHN0YXR1c0VsZW0ncyB0ZXh0IGluIHRoZSBwbGFjZWhvbGRlci5cclxuICAgIHN0YXR1c0VsZW0uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xyXG5cclxuICAgIHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICAgIC50aGVuKChyZXMpID0+IHtcclxuICAgICAgICAgICAgc3RhdHVzRWxlbS50ZXh0Q29udGVudCA9IFwiIFwiICsgcmVzLm1lc3NhZ2U7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIHN0YXR1c0VsZW0udGV4dENvbnRlbnQgPSAnY29ubmVjdGlvbiB0aW1lZCBvdXQnOyAgLy8gQWRqdXN0IGVycm9yIGhhbmRsaW5nIGlmIHJlcXVpcmVkLlxyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG4vLyBGZXRjaGVzIGRhdGEgZnJvbSB0aGUgZGVtb3RhYmxlIGFuZCBkaXNwbGF5cyBpdC5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQW5kRGlzcGxheVVzZXJzKG5hbWUpIHtcclxuICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdDaGVmdGFibGUnKTtcclxuICAgIGNvbnN0IHRhYmxlQm9keSA9IHRhYmxlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0Ym9keScpO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvY29udHJvbGxlcj9hY3Rpb249dGFibGUmbmFtZT0ke25hbWV9YCwge1xyXG4gICAgICAgIG1ldGhvZDogJ0dFVCdcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIGNvbnN0IGRlbW90YWJsZUNvbnRlbnQgPSByZXNwb25zZURhdGEuZGF0YTtcclxuXHJcbiAgICAvLyBBbHdheXMgY2xlYXIgb2xkLCBhbHJlYWR5IGZldGNoZWQgZGF0YSBiZWZvcmUgbmV3IGZldGNoaW5nIHByb2Nlc3MuXHJcbiAgICBpZiAodGFibGVCb2R5KSB7XHJcbiAgICAgICAgdGFibGVCb2R5LmlubmVySFRNTCA9ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGRlbW90YWJsZUNvbnRlbnQuZm9yRWFjaCh1c2VyID0+IHtcclxuICAgICAgICBjb25zdCByb3cgPSB0YWJsZUJvZHkuaW5zZXJ0Um93KCk7XHJcbiAgICAgICAgdXNlci5mb3JFYWNoKChmaWVsZCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2VsbCA9IHJvdy5pbnNlcnRDZWxsKGluZGV4KTtcclxuICAgICAgICAgICAgY2VsbC50ZXh0Q29udGVudCA9IGZpZWxkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8vIFRoaXMgZnVuY3Rpb24gcmVzZXRzIG9yIGluaXRpYWxpemVzIHRoZSBkZW1vdGFibGUuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNldFRhYmxlKG5hbWUpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvY29udHJvbGxlcj9hY3Rpb249aW5pdGlhdGUtdGFibGUmbmFtZT0ke25hbWV9YCwge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICBpZiAocmVzcG9uc2VEYXRhLnN1Y2Nlc3MpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXNldFJlc3VsdE1zZycpO1xyXG4gICAgICAgIG1lc3NhZ2VFbGVtZW50LnRleHRDb250ZW50ID0gXCJDaGVmdGFibGUgaW5pdGlhdGVkIHN1Y2Nlc3NmdWxseSFcIjtcclxuICAgICAgICBmZXRjaFRhYmxlRGF0YSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBhbGVydChcIkVycm9yIGluaXRpYXRpbmcgdGFibGUhXCIpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBJbnNlcnRzIG5ldyByZWNvcmRzIGludG8gdGhlIGRlbW90YWJsZS5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluc2VydENoZWZ0YWJsZShldmVudCwgbmFtZSkge1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICBjb25zdCBuYW1lVmFsdWUgPSBldmVudC50YXJnZXQuZWxlbWVudHNbMF0udmFsdWVcclxuICAgIGNvbnN0IFlPRVZhbHVlID0gZXZlbnQudGFyZ2V0LmVsZW1lbnRzWzFdLnZhbHVlXHJcbiAgICBjb25zdCBzZW5pb3JpdHlWYWx1ZSA9IGV2ZW50LnRhcmdldC5lbGVtZW50c1syXS52YWx1ZVxyXG4gICAgY29uc3QgbGljZW5zZVZhbHVlID0gZXZlbnQudGFyZ2V0LmVsZW1lbnRzWzNdLnZhbHVlXHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9jb250cm9sbGVyP2FjdGlvbj1pbnNlcnQtdGFibGUmbmFtZT0ke25hbWV9YCwge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICBjaGVmX25hbWU6IG5hbWVWYWx1ZSxcclxuICAgICAgICAgICAgeWVhcnNfb2ZfZXhwZXJpZW5jZTogWU9FVmFsdWUsXHJcbiAgICAgICAgICAgIHNlbmlvcml0eTogc2VuaW9yaXR5VmFsdWUsXHJcbiAgICAgICAgICAgIGNvb2tpbmdfbGljZW5zZTogbGljZW5zZVZhbHVlXHJcbiAgICAgICAgfSlcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIHJlc3BvbnNlSGFuZGxlcihyZXNwb25zZURhdGEsICdpbnNlcnRSZXN1bHRNc2cnLCBuYW1lLCBcIkRhdGEgaW5zZXJ0ZWQgc3VjY2Vzc2Z1bGx5IVwiKTtcclxufVxyXG5cclxuLy8gQ291bnRzIHJvd3MgaW4gdGhlIGRlbW90YWJsZS5cclxuLy8gTW9kaWZ5IHRoZSBmdW5jdGlvbiBhY2NvcmRpbmdseSBpZiB1c2luZyBkaWZmZXJlbnQgYWdncmVnYXRlIGZ1bmN0aW9ucyBvciBwcm9jZWR1cmVzLlxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY291bnRUYWJsZShuYW1lKSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2NvbnRyb2xsZXI/YWN0aW9uPWNvdW50LXRhYmxlJm5hbWU9JHtuYW1lfWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdHRVQnXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICBjb25zdCBtZXNzYWdlRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb3VudFJlc3VsdE1zZycpO1xyXG5cclxuICAgIGlmIChyZXNwb25zZURhdGEuc3VjY2Vzcykge1xyXG4gICAgICAgIGNvbnN0IHR1cGxlQ291bnQgPSByZXNwb25zZURhdGEuY291bnQ7XHJcbiAgICAgICAgbWVzc2FnZUVsZW1lbnQudGV4dENvbnRlbnQgPSBgVGhlIG51bWJlciBvZiB0dXBsZXMgaW4gZGVtb3RhYmxlOiAke3R1cGxlQ291bnR9YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWxlcnQoXCJFcnJvciBpbiBjb3VudCBkZW1vdGFibGUhXCIpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBVcGRhdGVzIG5hbWVzIGluIHRoZSByZWNpcGUgdGFibGUuXHJcbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZU5hbWVSZWNpcGV0YWJsZShldmVudCwgbmFtZSkge1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICBjb25zdCBvbGROYW1lVmFsdWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndXBkYXRlT2xkTmFtZScpLnZhbHVlO1xyXG4gICAgY29uc3QgbmV3TmFtZVZhbHVlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3VwZGF0ZU5ld05hbWUnKS52YWx1ZTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvdXBkYXRlLW5hbWUtcmVjaXBldGFibGUnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgIG9sZE5hbWU6IG9sZE5hbWVWYWx1ZSxcclxuICAgICAgICAgICAgbmV3TmFtZTogbmV3TmFtZVZhbHVlXHJcbiAgICAgICAgfSlcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIHJlc3BvbnNlSGFuZGxlcihyZXNwb25zZURhdGEsICd1cGRhdGVSZXN1bHRNc2cnLCBuYW1lLCBcIk5hbWUgdXBkYXRlZCBzdWNjZXNzZnVsbHkhXCIsIFwiRXJyb3IgdXBkYXRpbmcgbmFtZSFcIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc3BvbnNlSGFuZGxlcihkYXRhLCBpZCwgbmFtZSwgbWVzc2FnZSwgZXJyTWVzc2FnZSkge1xyXG4gICAgY29uc3QgbWVzc2FnZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XHJcblxyXG4gICAgaWYgKGRhdGEuc3VjY2Vzcykge1xyXG4gICAgICAgIGRhdGEudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xyXG4gICAgICAgIGZldGNoVGFibGVEYXRhKG5hbWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBtZXNzYWdlRWxlbWVudC50ZXh0Q29udGVudCA9IGVyck1lc3NhZ2U7XHJcbiAgICB9XHJcbn1cclxuIFxyXG4vLyBHZW5lcmFsIGZ1bmN0aW9uIHRvIHJlZnJlc2ggdGhlIGRpc3BsYXllZCB0YWJsZSBkYXRhLiBcclxuLy8gWW91IGNhbiBpbnZva2UgdGhpcyBhZnRlciBhbnkgdGFibGUtbW9kaWZ5aW5nIG9wZXJhdGlvbiB0byBrZWVwIGNvbnNpc3RlbmN5LlxyXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hUYWJsZURhdGEobmFtZSkge1xyXG4gICAgZmV0Y2hBbmREaXNwbGF5VXNlcnMobmFtZSk7XHJcbn1cclxuIl0sIm5hbWVzIjpbImNoZWNrRGJDb25uZWN0aW9uIiwic3RhdHVzRWxlbSIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJsb2FkaW5nR2lmRWxlbSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJzdHlsZSIsImRpc3BsYXkiLCJqc29uIiwidGhlbiIsInJlcyIsInRleHRDb250ZW50IiwibWVzc2FnZSIsImNhdGNoIiwiZXJyb3IiLCJmZXRjaEFuZERpc3BsYXlVc2VycyIsIm5hbWUiLCJ0YWJsZUVsZW1lbnQiLCJ0YWJsZUJvZHkiLCJxdWVyeVNlbGVjdG9yIiwicmVzcG9uc2VEYXRhIiwiZGVtb3RhYmxlQ29udGVudCIsImRhdGEiLCJpbm5lckhUTUwiLCJmb3JFYWNoIiwidXNlciIsInJvdyIsImluc2VydFJvdyIsImZpZWxkIiwiaW5kZXgiLCJjZWxsIiwiaW5zZXJ0Q2VsbCIsInJlc2V0VGFibGUiLCJzdWNjZXNzIiwibWVzc2FnZUVsZW1lbnQiLCJmZXRjaFRhYmxlRGF0YSIsImFsZXJ0IiwiaW5zZXJ0Q2hlZnRhYmxlIiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsIm5hbWVWYWx1ZSIsInRhcmdldCIsImVsZW1lbnRzIiwidmFsdWUiLCJZT0VWYWx1ZSIsInNlbmlvcml0eVZhbHVlIiwibGljZW5zZVZhbHVlIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiY2hlZl9uYW1lIiwieWVhcnNfb2ZfZXhwZXJpZW5jZSIsInNlbmlvcml0eSIsImNvb2tpbmdfbGljZW5zZSIsInJlc3BvbnNlSGFuZGxlciIsImNvdW50VGFibGUiLCJ0dXBsZUNvdW50IiwiY291bnQiLCJ1cGRhdGVOYW1lUmVjaXBldGFibGUiLCJvbGROYW1lVmFsdWUiLCJuZXdOYW1lVmFsdWUiLCJvbGROYW1lIiwibmV3TmFtZSIsImlkIiwiZXJyTWVzc2FnZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/api/scripts.js\n"));

/***/ })

});