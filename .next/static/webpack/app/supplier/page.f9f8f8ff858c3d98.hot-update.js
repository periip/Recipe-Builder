"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/supplier/page",{

/***/ "(app-pages-browser)/./src/app/api/scripts.js":
/*!********************************!*\
  !*** ./src/app/api/scripts.js ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkDbConnection: () => (/* binding */ checkDbConnection),\n/* harmony export */   countTable: () => (/* binding */ countTable),\n/* harmony export */   deleteIDRecipetable: () => (/* binding */ deleteIDRecipetable),\n/* harmony export */   fetchAndDisplayUsers: () => (/* binding */ fetchAndDisplayUsers),\n/* harmony export */   fetchTableData: () => (/* binding */ fetchTableData),\n/* harmony export */   insertCheftable: () => (/* binding */ insertCheftable),\n/* harmony export */   projectMenuItemTable: () => (/* binding */ projectMenuItemTable),\n/* harmony export */   resetTable: () => (/* binding */ resetTable),\n/* harmony export */   selectEquipmentTable: () => (/* binding */ selectEquipmentTable),\n/* harmony export */   updateNameRecipetable: () => (/* binding */ updateNameRecipetable)\n/* harmony export */ });\n/*\r\n * These functions below are for various webpage functionalities. \r\n * Each function serves to process data on the frontend:\r\n *      - Before sending requests to the backend.\r\n *      - After receiving responses from the backend.\r\n * \r\n * To tailor them to your specific needs,\r\n * adjust or expand these functions to match both your \r\n *   backend endpoints \r\n * and \r\n *   HTML structure.\r\n * \r\n */ // This function checks the database connection and updates its status on the frontend.\nasync function checkDbConnection() {\n    const statusElem = document.getElementById('dbStatus');\n    const loadingGifElem = document.getElementById('loadingGif');\n    const response = await fetch('/api/controller?action=check-db-connection', {\n        method: \"GET\"\n    });\n    // Hide the loading GIF once the response is received.\n    loadingGifElem.style.display = 'none';\n    // Display the statusElem's text in the placeholder.\n    statusElem.style.display = 'inline';\n    response.json().then((res)=>{\n        statusElem.textContent = \" \" + res.message;\n    }).catch((error)=>{\n        statusElem.textContent = 'connection timed out'; // Adjust error handling if required.\n    });\n}\n// Fetches data from the demotable and displays it.\nasync function fetchAndDisplayUsers(name) {\n    const tableElement = document.getElementById('Cheftable');\n    const tableBody = tableElement.querySelector('tbody');\n    const response = await fetch(\"/api/controller?action=table&name=\".concat(name), {\n        method: 'GET'\n    });\n    const responseData = await response.json();\n    const demotableContent = responseData.data;\n    // Always clear old, already fetched data before new fetching process.\n    if (tableBody) {\n        tableBody.innerHTML = '';\n    }\n    demotableContent.forEach((user)=>{\n        const row = tableBody.insertRow();\n        user.forEach((field, index)=>{\n            const cell = row.insertCell(index);\n            cell.textContent = field;\n        });\n    });\n}\n// This function resets or initializes the demotable.\nasync function resetTable(name) {\n    const response = await fetch(\"/api/controller?action=initiate-table&name=\".concat(name), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({})\n    });\n    const responseData = await response.json();\n    responseHandler(responseData, 'resetResultMsg', name, \"Table reset successfully!\", \"Error initiating table!\");\n}\n// Inserts new records into the demotable.\nasync function insertCheftable(event, name) {\n    event.preventDefault();\n    const nameValue = event.target.elements[0].value;\n    const YOEValue = event.target.elements[1].value;\n    const seniorityValue = event.target.elements[2].value;\n    const licenseValue = event.target.elements[3].value;\n    const response = await fetch(\"/api/controller?action=insert-table&name=\".concat(name), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            chef_name: nameValue,\n            years_of_experience: YOEValue,\n            seniority: seniorityValue,\n            cooking_license: licenseValue\n        })\n    });\n    const responseData = await response.json();\n    responseHandler(responseData, 'insertResultMsg', name, \"Data inserted successfully!\", \"Error inserting data!\");\n}\nasync function selectEquipmentTable(event, name) {\n    event.preventDefault();\n    const tableElement = document.getElementById('Cheftable');\n    const tableBody = tableElement.querySelector('tbody');\n    tableBody.innerHTML = '';\n    const condition = event.target.elements[0].checked ? \"both\" : \"individual\";\n    const nameString = event.target.elements[2].value;\n    const materialString = event.target.elements[3].value;\n    const response = await fetch(\"/api/controller?action=select-equipment-table\", {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            condition,\n            nameString,\n            materialString\n        })\n    });\n    const responseData = await response.json();\n    const data = responseData.data;\n    data.forEach((user)=>{\n        const row = tableBody.insertRow();\n        user.forEach((field, index)=>{\n            const cell = row.insertCell(index);\n            cell.textContent = field;\n        });\n    });\n// cant refetch data from the table\n}\nasync function projectMenuItemTable(event, attributes) {\n    event.preventDefault();\n    const tableElement = document.getElementById('Cheftable');\n    const tableBody = tableElement.querySelector('tbody');\n    const tableHead = tableElement.querySelector('thead');\n    tableBody.innerHTML = '';\n    const response = await fetch(\"/api/controller?action=project-menu-item-table\", {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            attributes\n        })\n    });\n    const responseData = await response.json();\n    const data = responseData.data;\n    console.log(data);\n    data.forEach((user)=>{\n        const row = tableBody.insertRow();\n        user.forEach((field, index)=>{\n            const cell = row.insertCell(index);\n            cell.textContent = field;\n        });\n    });\n// cant refetch data from the table\n}\n// Counts rows in the demotable.\n// Modify the function accordingly if using different aggregate functions or procedures.\nasync function countTable(name) {\n    const response = await fetch(\"/api/controller?action=count-table&name=\".concat(name), {\n        method: 'GET'\n    });\n    const responseData = await response.json();\n    const tupleCount = responseData.count;\n    const message = \"The number of tuples in demotable: \".concat(tupleCount);\n    responseHandler(responseData, 'countResultMsg', name, message, \"Error counting tuples!\");\n}\n// Updates names in the recipe table.\nasync function updateNameRecipetable(event, name) {\n    event.preventDefault();\n    const oldNameValue = document.getElementById('updateOldName').value;\n    const newNameValue = document.getElementById('updateNewName').value;\n    const response = await fetch(\"/api/controller?action=update-name-recipetable&name=\".concat(name), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            oldName: oldNameValue,\n            newName: newNameValue\n        })\n    });\n    const responseData = await response.json();\n    responseHandler(responseData, 'updateResultMsg', name, \"Name updated successfully!\", \"Error updating name!\");\n}\n// Delete ID in the recipe table.\nasync function deleteIDRecipetable(event, name) {\n    event.preventDefault();\n    const recipeId = document.getElementById('deleteOldId').value;\n    const response = await fetch(\"/api/controller?action=delete-id-recipetable&name=\".concat(name), {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            recipeId\n        })\n    });\n    const responseData = await response.json();\n    responseHandler(responseData, 'deleteIdResultMsg', name, \"Recipe deleted successfully!\", \"Error deleting recipe!\");\n}\nfunction responseHandler(data, id, name, message, errMessage) {\n    const messageElement = document.getElementById(id);\n    if (data.success) {\n        data.textContent = message;\n        fetchTableData(name);\n    } else {\n        messageElement.textContent = errMessage;\n    }\n}\n// General function to refresh the displayed table data. \n// You can invoke this after any table-modifying operation to keep consistency.\nfunction fetchTableData(name) {\n    fetchAndDisplayUsers(name);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvYXBpL3NjcmlwdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUdELHVGQUF1RjtBQUNoRixlQUFlQTtJQUNsQixNQUFNQyxhQUFhQyxTQUFTQyxjQUFjLENBQUM7SUFDM0MsTUFBTUMsaUJBQWlCRixTQUFTQyxjQUFjLENBQUM7SUFFL0MsTUFBTUUsV0FBVyxNQUFNQyxNQUFNLDhDQUE4QztRQUN2RUMsUUFBUTtJQUNaO0lBQ0Esc0RBQXNEO0lBQ3RESCxlQUFlSSxLQUFLLENBQUNDLE9BQU8sR0FBRztJQUMvQixvREFBb0Q7SUFDcERSLFdBQVdPLEtBQUssQ0FBQ0MsT0FBTyxHQUFHO0lBRTNCSixTQUFTSyxJQUFJLEdBQ1JDLElBQUksQ0FBQyxDQUFDQztRQUNIWCxXQUFXWSxXQUFXLEdBQUcsTUFBTUQsSUFBSUUsT0FBTztJQUM5QyxHQUNDQyxLQUFLLENBQUMsQ0FBQ0M7UUFDSmYsV0FBV1ksV0FBVyxHQUFHLHdCQUF5QixxQ0FBcUM7SUFDM0Y7QUFDUjtBQUVBLG1EQUFtRDtBQUM1QyxlQUFlSSxxQkFBcUJDLElBQUk7SUFDM0MsTUFBTUMsZUFBZWpCLFNBQVNDLGNBQWMsQ0FBQztJQUM3QyxNQUFNaUIsWUFBWUQsYUFBYUUsYUFBYSxDQUFDO0lBRTdDLE1BQU1oQixXQUFXLE1BQU1DLE1BQU0scUNBQTBDLE9BQUxZLE9BQVE7UUFDdEVYLFFBQVE7SUFDWjtJQUVBLE1BQU1lLGVBQWUsTUFBTWpCLFNBQVNLLElBQUk7SUFDeEMsTUFBTWEsbUJBQW1CRCxhQUFhRSxJQUFJO0lBRTFDLHNFQUFzRTtJQUN0RSxJQUFJSixXQUFXO1FBQ1hBLFVBQVVLLFNBQVMsR0FBRztJQUMxQjtJQUVBRixpQkFBaUJHLE9BQU8sQ0FBQ0MsQ0FBQUE7UUFDckIsTUFBTUMsTUFBTVIsVUFBVVMsU0FBUztRQUMvQkYsS0FBS0QsT0FBTyxDQUFDLENBQUNJLE9BQU9DO1lBQ2pCLE1BQU1DLE9BQU9KLElBQUlLLFVBQVUsQ0FBQ0Y7WUFDNUJDLEtBQUtuQixXQUFXLEdBQUdpQjtRQUN2QjtJQUNKO0FBQ0o7QUFFQSxxREFBcUQ7QUFDOUMsZUFBZUksV0FBV2hCLElBQUk7SUFDakMsTUFBTWIsV0FBVyxNQUFNQyxNQUFNLDhDQUFtRCxPQUFMWSxPQUFRO1FBQy9FWCxRQUFRO1FBQ1I0QixTQUFTO1lBQ0wsZ0JBQWdCO1FBQ3BCO1FBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQyxDQUFDO0lBQzFCO0lBQ0EsTUFBTWhCLGVBQWUsTUFBTWpCLFNBQVNLLElBQUk7SUFFeEM2QixnQkFBZ0JqQixjQUFjLGtCQUFrQkosTUFBTSw2QkFBNkI7QUFDdkY7QUFFQSwwQ0FBMEM7QUFDbkMsZUFBZXNCLGdCQUFnQkMsS0FBSyxFQUFFdkIsSUFBSTtJQUM3Q3VCLE1BQU1DLGNBQWM7SUFFcEIsTUFBTUMsWUFBWUYsTUFBTUcsTUFBTSxDQUFDQyxRQUFRLENBQUMsRUFBRSxDQUFDQyxLQUFLO0lBQ2hELE1BQU1DLFdBQVdOLE1BQU1HLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDLEVBQUUsQ0FBQ0MsS0FBSztJQUMvQyxNQUFNRSxpQkFBaUJQLE1BQU1HLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDLEVBQUUsQ0FBQ0MsS0FBSztJQUNyRCxNQUFNRyxlQUFlUixNQUFNRyxNQUFNLENBQUNDLFFBQVEsQ0FBQyxFQUFFLENBQUNDLEtBQUs7SUFFbkQsTUFBTXpDLFdBQVcsTUFBTUMsTUFBTSw0Q0FBaUQsT0FBTFksT0FBUTtRQUM3RVgsUUFBUTtRQUNSNEIsU0FBUztZQUNMLGdCQUFnQjtRQUNwQjtRQUNBQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7WUFDakJZLFdBQVdQO1lBQ1hRLHFCQUFxQko7WUFDckJLLFdBQVdKO1lBQ1hLLGlCQUFpQko7UUFDckI7SUFDSjtJQUVBLE1BQU0zQixlQUFlLE1BQU1qQixTQUFTSyxJQUFJO0lBQ3hDNkIsZ0JBQWdCakIsY0FBYyxtQkFBbUJKLE1BQU0sK0JBQStCO0FBQzFGO0FBRU8sZUFBZW9DLHFCQUFxQmIsS0FBSyxFQUFFdkIsSUFBSTtJQUNsRHVCLE1BQU1DLGNBQWM7SUFDcEIsTUFBTXZCLGVBQWVqQixTQUFTQyxjQUFjLENBQUM7SUFDN0MsTUFBTWlCLFlBQVlELGFBQWFFLGFBQWEsQ0FBQztJQUM3Q0QsVUFBVUssU0FBUyxHQUFHO0lBRXRCLE1BQU04QixZQUFZZCxNQUFNRyxNQUFNLENBQUNDLFFBQVEsQ0FBQyxFQUFFLENBQUNXLE9BQU8sR0FBRyxTQUFTO0lBQzlELE1BQU1DLGFBQWFoQixNQUFNRyxNQUFNLENBQUNDLFFBQVEsQ0FBQyxFQUFFLENBQUNDLEtBQUs7SUFDakQsTUFBTVksaUJBQWlCakIsTUFBTUcsTUFBTSxDQUFDQyxRQUFRLENBQUMsRUFBRSxDQUFDQyxLQUFLO0lBR3JELE1BQU16QyxXQUFXLE1BQU1DLE1BQU8saURBQWdEO1FBQzFFQyxRQUFRO1FBQ1I0QixTQUFTO1lBQ0wsZ0JBQWdCO1FBQ3BCO1FBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztZQUNqQmlCO1lBQ0FFO1lBQ0FDO1FBQ0o7SUFDSjtJQUVBLE1BQU1wQyxlQUFlLE1BQU1qQixTQUFTSyxJQUFJO0lBQ3hDLE1BQU1jLE9BQU9GLGFBQWFFLElBQUk7SUFFOUJBLEtBQUtFLE9BQU8sQ0FBQ0MsQ0FBQUE7UUFDVCxNQUFNQyxNQUFNUixVQUFVUyxTQUFTO1FBQy9CRixLQUFLRCxPQUFPLENBQUMsQ0FBQ0ksT0FBT0M7WUFDakIsTUFBTUMsT0FBT0osSUFBSUssVUFBVSxDQUFDRjtZQUM1QkMsS0FBS25CLFdBQVcsR0FBR2lCO1FBQ3ZCO0lBQ0o7QUFDQSxtQ0FBbUM7QUFDdkM7QUFFTyxlQUFlNkIscUJBQXFCbEIsS0FBSyxFQUFFbUIsVUFBVTtJQUN4RG5CLE1BQU1DLGNBQWM7SUFDcEIsTUFBTXZCLGVBQWVqQixTQUFTQyxjQUFjLENBQUM7SUFDN0MsTUFBTWlCLFlBQVlELGFBQWFFLGFBQWEsQ0FBQztJQUM3QyxNQUFNd0MsWUFBWTFDLGFBQWFFLGFBQWEsQ0FBQztJQUM3Q0QsVUFBVUssU0FBUyxHQUFHO0lBRXRCLE1BQU1wQixXQUFXLE1BQU1DLE1BQU8sa0RBQWlEO1FBQzNFQyxRQUFRO1FBQ1I0QixTQUFTO1lBQ0wsZ0JBQWdCO1FBQ3BCO1FBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztZQUNqQnNCO1FBQ0o7SUFDSjtJQUVBLE1BQU10QyxlQUFlLE1BQU1qQixTQUFTSyxJQUFJO0lBQ3hDLE1BQU1jLE9BQU9GLGFBQWFFLElBQUk7SUFDOUJzQyxRQUFRQyxHQUFHLENBQUN2QztJQUNaQSxLQUFLRSxPQUFPLENBQUNDLENBQUFBO1FBQ1QsTUFBTUMsTUFBTVIsVUFBVVMsU0FBUztRQUMvQkYsS0FBS0QsT0FBTyxDQUFDLENBQUNJLE9BQU9DO1lBQ2pCLE1BQU1DLE9BQU9KLElBQUlLLFVBQVUsQ0FBQ0Y7WUFDNUJDLEtBQUtuQixXQUFXLEdBQUdpQjtRQUN2QjtJQUNKO0FBQ0EsbUNBQW1DO0FBQ3ZDO0FBRUEsZ0NBQWdDO0FBQ2hDLHdGQUF3RjtBQUNqRixlQUFla0MsV0FBVzlDLElBQUk7SUFDakMsTUFBTWIsV0FBVyxNQUFNQyxNQUFNLDJDQUFnRCxPQUFMWSxPQUFRO1FBQzVFWCxRQUFRO0lBQ1o7SUFFQSxNQUFNZSxlQUFlLE1BQU1qQixTQUFTSyxJQUFJO0lBQ3hDLE1BQU11RCxhQUFhM0MsYUFBYTRDLEtBQUs7SUFDckMsTUFBTXBELFVBQVUsc0NBQWlELE9BQVhtRDtJQUN0RDFCLGdCQUFnQmpCLGNBQWMsa0JBQWtCSixNQUFNSixTQUFTO0FBQ25FO0FBRUEscUNBQXFDO0FBQzlCLGVBQWVxRCxzQkFBc0IxQixLQUFLLEVBQUV2QixJQUFJO0lBQ25EdUIsTUFBTUMsY0FBYztJQUVwQixNQUFNMEIsZUFBZWxFLFNBQVNDLGNBQWMsQ0FBQyxpQkFBaUIyQyxLQUFLO0lBQ25FLE1BQU11QixlQUFlbkUsU0FBU0MsY0FBYyxDQUFDLGlCQUFpQjJDLEtBQUs7SUFFbkUsTUFBTXpDLFdBQVcsTUFBTUMsTUFBTSx1REFBNEQsT0FBTFksT0FBUTtRQUN4RlgsUUFBUTtRQUNSNEIsU0FBUztZQUNMLGdCQUFnQjtRQUNwQjtRQUNBQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7WUFDakJnQyxTQUFTRjtZQUNURyxTQUFTRjtRQUNiO0lBQ0o7SUFFQSxNQUFNL0MsZUFBZSxNQUFNakIsU0FBU0ssSUFBSTtJQUN4QzZCLGdCQUFnQmpCLGNBQWMsbUJBQW1CSixNQUFNLDhCQUE4QjtBQUN6RjtBQUVBLGlDQUFpQztBQUMxQixlQUFlc0Qsb0JBQW9CL0IsS0FBSyxFQUFFdkIsSUFBSTtJQUNqRHVCLE1BQU1DLGNBQWM7SUFFcEIsTUFBTStCLFdBQVd2RSxTQUFTQyxjQUFjLENBQUMsZUFBZTJDLEtBQUs7SUFFN0QsTUFBTXpDLFdBQVcsTUFBTUMsTUFBTSxxREFBMEQsT0FBTFksT0FBUTtRQUN0RlgsUUFBUTtRQUNSNEIsU0FBUztZQUNMLGdCQUFnQjtRQUNwQjtRQUNBQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7WUFDakJtQztRQUNKO0lBQ0o7SUFFQSxNQUFNbkQsZUFBZSxNQUFNakIsU0FBU0ssSUFBSTtJQUN4QzZCLGdCQUFnQmpCLGNBQWMscUJBQXFCSixNQUFNLGdDQUFnQztBQUM3RjtBQUVBLFNBQVNxQixnQkFBZ0JmLElBQUksRUFBRWtELEVBQUUsRUFBRXhELElBQUksRUFBRUosT0FBTyxFQUFFNkQsVUFBVTtJQUN4RCxNQUFNQyxpQkFBaUIxRSxTQUFTQyxjQUFjLENBQUN1RTtJQUUvQyxJQUFJbEQsS0FBS3FELE9BQU8sRUFBRTtRQUNkckQsS0FBS1gsV0FBVyxHQUFHQztRQUNuQmdFLGVBQWU1RDtJQUNuQixPQUFPO1FBQ0gwRCxlQUFlL0QsV0FBVyxHQUFHOEQ7SUFDakM7QUFDSjtBQUVBLHlEQUF5RDtBQUN6RCwrRUFBK0U7QUFDeEUsU0FBU0csZUFBZTVELElBQUk7SUFDL0JELHFCQUFxQkM7QUFDekIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xccGVycnlcXE9uZURyaXZlXFxEZXNrdG9wXFxDb2xsZWdlXFxZZWFyIDNcXFQyXFxDUFNDIDMwNFxccHJvamVjdF9qNG0xbl9uMHQxdl92N2w5dC1tYWluXFxzcmNcXGFwcFxcYXBpXFxzY3JpcHRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIFRoZXNlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgZm9yIHZhcmlvdXMgd2VicGFnZSBmdW5jdGlvbmFsaXRpZXMuIFxyXG4gKiBFYWNoIGZ1bmN0aW9uIHNlcnZlcyB0byBwcm9jZXNzIGRhdGEgb24gdGhlIGZyb250ZW5kOlxyXG4gKiAgICAgIC0gQmVmb3JlIHNlbmRpbmcgcmVxdWVzdHMgdG8gdGhlIGJhY2tlbmQuXHJcbiAqICAgICAgLSBBZnRlciByZWNlaXZpbmcgcmVzcG9uc2VzIGZyb20gdGhlIGJhY2tlbmQuXHJcbiAqIFxyXG4gKiBUbyB0YWlsb3IgdGhlbSB0byB5b3VyIHNwZWNpZmljIG5lZWRzLFxyXG4gKiBhZGp1c3Qgb3IgZXhwYW5kIHRoZXNlIGZ1bmN0aW9ucyB0byBtYXRjaCBib3RoIHlvdXIgXHJcbiAqICAgYmFja2VuZCBlbmRwb2ludHMgXHJcbiAqIGFuZCBcclxuICogICBIVE1MIHN0cnVjdHVyZS5cclxuICogXHJcbiAqL1xyXG5cclxuXHJcbi8vIFRoaXMgZnVuY3Rpb24gY2hlY2tzIHRoZSBkYXRhYmFzZSBjb25uZWN0aW9uIGFuZCB1cGRhdGVzIGl0cyBzdGF0dXMgb24gdGhlIGZyb250ZW5kLlxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tEYkNvbm5lY3Rpb24oKSB7XHJcbiAgICBjb25zdCBzdGF0dXNFbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RiU3RhdHVzJyk7XHJcbiAgICBjb25zdCBsb2FkaW5nR2lmRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2FkaW5nR2lmJyk7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9jb250cm9sbGVyP2FjdGlvbj1jaGVjay1kYi1jb25uZWN0aW9uJywge1xyXG4gICAgICAgIG1ldGhvZDogXCJHRVRcIlxyXG4gICAgfSk7XHJcbiAgICAvLyBIaWRlIHRoZSBsb2FkaW5nIEdJRiBvbmNlIHRoZSByZXNwb25zZSBpcyByZWNlaXZlZC5cclxuICAgIGxvYWRpbmdHaWZFbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAvLyBEaXNwbGF5IHRoZSBzdGF0dXNFbGVtJ3MgdGV4dCBpbiB0aGUgcGxhY2Vob2xkZXIuXHJcbiAgICBzdGF0dXNFbGVtLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcclxuXHJcbiAgICByZXNwb25zZS5qc29uKClcclxuICAgICAgICAudGhlbigocmVzKSA9PiB7XHJcbiAgICAgICAgICAgIHN0YXR1c0VsZW0udGV4dENvbnRlbnQgPSBcIiBcIiArIHJlcy5tZXNzYWdlO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBzdGF0dXNFbGVtLnRleHRDb250ZW50ID0gJ2Nvbm5lY3Rpb24gdGltZWQgb3V0JzsgIC8vIEFkanVzdCBlcnJvciBoYW5kbGluZyBpZiByZXF1aXJlZC5cclxuICAgICAgICB9KTtcclxufVxyXG5cclxuLy8gRmV0Y2hlcyBkYXRhIGZyb20gdGhlIGRlbW90YWJsZSBhbmQgZGlzcGxheXMgaXQuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaEFuZERpc3BsYXlVc2VycyhuYW1lKSB7XHJcbiAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnQ2hlZnRhYmxlJyk7XHJcbiAgICBjb25zdCB0YWJsZUJvZHkgPSB0YWJsZUVsZW1lbnQucXVlcnlTZWxlY3RvcigndGJvZHknKTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2NvbnRyb2xsZXI/YWN0aW9uPXRhYmxlJm5hbWU9JHtuYW1lfWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdHRVQnXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICBjb25zdCBkZW1vdGFibGVDb250ZW50ID0gcmVzcG9uc2VEYXRhLmRhdGE7XHJcblxyXG4gICAgLy8gQWx3YXlzIGNsZWFyIG9sZCwgYWxyZWFkeSBmZXRjaGVkIGRhdGEgYmVmb3JlIG5ldyBmZXRjaGluZyBwcm9jZXNzLlxyXG4gICAgaWYgKHRhYmxlQm9keSkge1xyXG4gICAgICAgIHRhYmxlQm9keS5pbm5lckhUTUwgPSAnJztcclxuICAgIH1cclxuXHJcbiAgICBkZW1vdGFibGVDb250ZW50LmZvckVhY2godXNlciA9PiB7XHJcbiAgICAgICAgY29uc3Qgcm93ID0gdGFibGVCb2R5Lmluc2VydFJvdygpO1xyXG4gICAgICAgIHVzZXIuZm9yRWFjaCgoZmllbGQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSByb3cuaW5zZXJ0Q2VsbChpbmRleCk7XHJcbiAgICAgICAgICAgIGNlbGwudGV4dENvbnRlbnQgPSBmaWVsZDtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vLyBUaGlzIGZ1bmN0aW9uIHJlc2V0cyBvciBpbml0aWFsaXplcyB0aGUgZGVtb3RhYmxlLlxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzZXRUYWJsZShuYW1lKSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2NvbnRyb2xsZXI/YWN0aW9uPWluaXRpYXRlLXRhYmxlJm5hbWU9JHtuYW1lfWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHt9KVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgcmVzcG9uc2VIYW5kbGVyKHJlc3BvbnNlRGF0YSwgJ3Jlc2V0UmVzdWx0TXNnJywgbmFtZSwgXCJUYWJsZSByZXNldCBzdWNjZXNzZnVsbHkhXCIsIFwiRXJyb3IgaW5pdGlhdGluZyB0YWJsZSFcIik7XHJcbn1cclxuXHJcbi8vIEluc2VydHMgbmV3IHJlY29yZHMgaW50byB0aGUgZGVtb3RhYmxlLlxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5zZXJ0Q2hlZnRhYmxlKGV2ZW50LCBuYW1lKSB7XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgIGNvbnN0IG5hbWVWYWx1ZSA9IGV2ZW50LnRhcmdldC5lbGVtZW50c1swXS52YWx1ZVxyXG4gICAgY29uc3QgWU9FVmFsdWUgPSBldmVudC50YXJnZXQuZWxlbWVudHNbMV0udmFsdWVcclxuICAgIGNvbnN0IHNlbmlvcml0eVZhbHVlID0gZXZlbnQudGFyZ2V0LmVsZW1lbnRzWzJdLnZhbHVlXHJcbiAgICBjb25zdCBsaWNlbnNlVmFsdWUgPSBldmVudC50YXJnZXQuZWxlbWVudHNbM10udmFsdWVcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2NvbnRyb2xsZXI/YWN0aW9uPWluc2VydC10YWJsZSZuYW1lPSR7bmFtZX1gLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgIGNoZWZfbmFtZTogbmFtZVZhbHVlLFxyXG4gICAgICAgICAgICB5ZWFyc19vZl9leHBlcmllbmNlOiBZT0VWYWx1ZSxcclxuICAgICAgICAgICAgc2VuaW9yaXR5OiBzZW5pb3JpdHlWYWx1ZSxcclxuICAgICAgICAgICAgY29va2luZ19saWNlbnNlOiBsaWNlbnNlVmFsdWVcclxuICAgICAgICB9KVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgcmVzcG9uc2VIYW5kbGVyKHJlc3BvbnNlRGF0YSwgJ2luc2VydFJlc3VsdE1zZycsIG5hbWUsIFwiRGF0YSBpbnNlcnRlZCBzdWNjZXNzZnVsbHkhXCIsIFwiRXJyb3IgaW5zZXJ0aW5nIGRhdGEhXCIpO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VsZWN0RXF1aXBtZW50VGFibGUoZXZlbnQsIG5hbWUpIHtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnQ2hlZnRhYmxlJyk7XHJcbiAgICBjb25zdCB0YWJsZUJvZHkgPSB0YWJsZUVsZW1lbnQucXVlcnlTZWxlY3RvcigndGJvZHknKTtcclxuICAgIHRhYmxlQm9keS5pbm5lckhUTUwgPSAnJztcclxuXHJcbiAgICBjb25zdCBjb25kaXRpb24gPSBldmVudC50YXJnZXQuZWxlbWVudHNbMF0uY2hlY2tlZCA/IFwiYm90aFwiIDogXCJpbmRpdmlkdWFsXCI7XHJcbiAgICBjb25zdCBuYW1lU3RyaW5nID0gZXZlbnQudGFyZ2V0LmVsZW1lbnRzWzJdLnZhbHVlXHJcbiAgICBjb25zdCBtYXRlcmlhbFN0cmluZyA9IGV2ZW50LnRhcmdldC5lbGVtZW50c1szXS52YWx1ZVxyXG5cclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2NvbnRyb2xsZXI/YWN0aW9uPXNlbGVjdC1lcXVpcG1lbnQtdGFibGVgLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgIGNvbmRpdGlvbixcclxuICAgICAgICAgICAgbmFtZVN0cmluZyxcclxuICAgICAgICAgICAgbWF0ZXJpYWxTdHJpbmdcclxuICAgICAgICB9KVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlRGF0YS5kYXRhO1xyXG5cclxuICAgIGRhdGEuZm9yRWFjaCh1c2VyID0+IHtcclxuICAgICAgICBjb25zdCByb3cgPSB0YWJsZUJvZHkuaW5zZXJ0Um93KCk7XHJcbiAgICAgICAgdXNlci5mb3JFYWNoKChmaWVsZCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2VsbCA9IHJvdy5pbnNlcnRDZWxsKGluZGV4KTtcclxuICAgICAgICAgICAgY2VsbC50ZXh0Q29udGVudCA9IGZpZWxkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICAvLyBjYW50IHJlZmV0Y2ggZGF0YSBmcm9tIHRoZSB0YWJsZVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvamVjdE1lbnVJdGVtVGFibGUoZXZlbnQsIGF0dHJpYnV0ZXMpIHtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnQ2hlZnRhYmxlJyk7XHJcbiAgICBjb25zdCB0YWJsZUJvZHkgPSB0YWJsZUVsZW1lbnQucXVlcnlTZWxlY3RvcigndGJvZHknKTtcclxuICAgIGNvbnN0IHRhYmxlSGVhZCA9IHRhYmxlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0aGVhZCcpO1xyXG4gICAgdGFibGVCb2R5LmlubmVySFRNTCA9ICcnO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvY29udHJvbGxlcj9hY3Rpb249cHJvamVjdC1tZW51LWl0ZW0tdGFibGVgLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNcclxuICAgICAgICB9KVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlRGF0YS5kYXRhO1xyXG4gICAgY29uc29sZS5sb2coZGF0YSlcclxuICAgIGRhdGEuZm9yRWFjaCh1c2VyID0+IHtcclxuICAgICAgICBjb25zdCByb3cgPSB0YWJsZUJvZHkuaW5zZXJ0Um93KCk7XHJcbiAgICAgICAgdXNlci5mb3JFYWNoKChmaWVsZCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2VsbCA9IHJvdy5pbnNlcnRDZWxsKGluZGV4KTtcclxuICAgICAgICAgICAgY2VsbC50ZXh0Q29udGVudCA9IGZpZWxkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICAvLyBjYW50IHJlZmV0Y2ggZGF0YSBmcm9tIHRoZSB0YWJsZVxyXG59XHJcblxyXG4vLyBDb3VudHMgcm93cyBpbiB0aGUgZGVtb3RhYmxlLlxyXG4vLyBNb2RpZnkgdGhlIGZ1bmN0aW9uIGFjY29yZGluZ2x5IGlmIHVzaW5nIGRpZmZlcmVudCBhZ2dyZWdhdGUgZnVuY3Rpb25zIG9yIHByb2NlZHVyZXMuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb3VudFRhYmxlKG5hbWUpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvY29udHJvbGxlcj9hY3Rpb249Y291bnQtdGFibGUmbmFtZT0ke25hbWV9YCwge1xyXG4gICAgICAgIG1ldGhvZDogJ0dFVCdcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIGNvbnN0IHR1cGxlQ291bnQgPSByZXNwb25zZURhdGEuY291bnQ7XHJcbiAgICBjb25zdCBtZXNzYWdlID0gYFRoZSBudW1iZXIgb2YgdHVwbGVzIGluIGRlbW90YWJsZTogJHt0dXBsZUNvdW50fWA7XHJcbiAgICByZXNwb25zZUhhbmRsZXIocmVzcG9uc2VEYXRhLCAnY291bnRSZXN1bHRNc2cnLCBuYW1lLCBtZXNzYWdlLCBcIkVycm9yIGNvdW50aW5nIHR1cGxlcyFcIik7XHJcbn1cclxuXHJcbi8vIFVwZGF0ZXMgbmFtZXMgaW4gdGhlIHJlY2lwZSB0YWJsZS5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZU5hbWVSZWNpcGV0YWJsZShldmVudCwgbmFtZSkge1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICBjb25zdCBvbGROYW1lVmFsdWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndXBkYXRlT2xkTmFtZScpLnZhbHVlO1xyXG4gICAgY29uc3QgbmV3TmFtZVZhbHVlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3VwZGF0ZU5ld05hbWUnKS52YWx1ZTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2NvbnRyb2xsZXI/YWN0aW9uPXVwZGF0ZS1uYW1lLXJlY2lwZXRhYmxlJm5hbWU9JHtuYW1lfWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgb2xkTmFtZTogb2xkTmFtZVZhbHVlLFxyXG4gICAgICAgICAgICBuZXdOYW1lOiBuZXdOYW1lVmFsdWVcclxuICAgICAgICB9KVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgcmVzcG9uc2VIYW5kbGVyKHJlc3BvbnNlRGF0YSwgJ3VwZGF0ZVJlc3VsdE1zZycsIG5hbWUsIFwiTmFtZSB1cGRhdGVkIHN1Y2Nlc3NmdWxseSFcIiwgXCJFcnJvciB1cGRhdGluZyBuYW1lIVwiKTtcclxufVxyXG5cclxuLy8gRGVsZXRlIElEIGluIHRoZSByZWNpcGUgdGFibGUuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVJRFJlY2lwZXRhYmxlKGV2ZW50LCBuYW1lKSB7XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgIGNvbnN0IHJlY2lwZUlkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RlbGV0ZU9sZElkJykudmFsdWU7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9jb250cm9sbGVyP2FjdGlvbj1kZWxldGUtaWQtcmVjaXBldGFibGUmbmFtZT0ke25hbWV9YCwge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICByZWNpcGVJZFxyXG4gICAgICAgIH0pXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICByZXNwb25zZUhhbmRsZXIocmVzcG9uc2VEYXRhLCAnZGVsZXRlSWRSZXN1bHRNc2cnLCBuYW1lLCBcIlJlY2lwZSBkZWxldGVkIHN1Y2Nlc3NmdWxseSFcIiwgXCJFcnJvciBkZWxldGluZyByZWNpcGUhXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNwb25zZUhhbmRsZXIoZGF0YSwgaWQsIG5hbWUsIG1lc3NhZ2UsIGVyck1lc3NhZ2UpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2VFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xyXG5cclxuICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcclxuICAgICAgICBkYXRhLnRleHRDb250ZW50ID0gbWVzc2FnZTtcclxuICAgICAgICBmZXRjaFRhYmxlRGF0YShuYW1lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbWVzc2FnZUVsZW1lbnQudGV4dENvbnRlbnQgPSBlcnJNZXNzYWdlO1xyXG4gICAgfVxyXG59XHJcbiBcclxuLy8gR2VuZXJhbCBmdW5jdGlvbiB0byByZWZyZXNoIHRoZSBkaXNwbGF5ZWQgdGFibGUgZGF0YS4gXHJcbi8vIFlvdSBjYW4gaW52b2tlIHRoaXMgYWZ0ZXIgYW55IHRhYmxlLW1vZGlmeWluZyBvcGVyYXRpb24gdG8ga2VlcCBjb25zaXN0ZW5jeS5cclxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoVGFibGVEYXRhKG5hbWUpIHtcclxuICAgIGZldGNoQW5kRGlzcGxheVVzZXJzKG5hbWUpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJjaGVja0RiQ29ubmVjdGlvbiIsInN0YXR1c0VsZW0iLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwibG9hZGluZ0dpZkVsZW0iLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwic3R5bGUiLCJkaXNwbGF5IiwianNvbiIsInRoZW4iLCJyZXMiLCJ0ZXh0Q29udGVudCIsIm1lc3NhZ2UiLCJjYXRjaCIsImVycm9yIiwiZmV0Y2hBbmREaXNwbGF5VXNlcnMiLCJuYW1lIiwidGFibGVFbGVtZW50IiwidGFibGVCb2R5IiwicXVlcnlTZWxlY3RvciIsInJlc3BvbnNlRGF0YSIsImRlbW90YWJsZUNvbnRlbnQiLCJkYXRhIiwiaW5uZXJIVE1MIiwiZm9yRWFjaCIsInVzZXIiLCJyb3ciLCJpbnNlcnRSb3ciLCJmaWVsZCIsImluZGV4IiwiY2VsbCIsImluc2VydENlbGwiLCJyZXNldFRhYmxlIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicmVzcG9uc2VIYW5kbGVyIiwiaW5zZXJ0Q2hlZnRhYmxlIiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsIm5hbWVWYWx1ZSIsInRhcmdldCIsImVsZW1lbnRzIiwidmFsdWUiLCJZT0VWYWx1ZSIsInNlbmlvcml0eVZhbHVlIiwibGljZW5zZVZhbHVlIiwiY2hlZl9uYW1lIiwieWVhcnNfb2ZfZXhwZXJpZW5jZSIsInNlbmlvcml0eSIsImNvb2tpbmdfbGljZW5zZSIsInNlbGVjdEVxdWlwbWVudFRhYmxlIiwiY29uZGl0aW9uIiwiY2hlY2tlZCIsIm5hbWVTdHJpbmciLCJtYXRlcmlhbFN0cmluZyIsInByb2plY3RNZW51SXRlbVRhYmxlIiwiYXR0cmlidXRlcyIsInRhYmxlSGVhZCIsImNvbnNvbGUiLCJsb2ciLCJjb3VudFRhYmxlIiwidHVwbGVDb3VudCIsImNvdW50IiwidXBkYXRlTmFtZVJlY2lwZXRhYmxlIiwib2xkTmFtZVZhbHVlIiwibmV3TmFtZVZhbHVlIiwib2xkTmFtZSIsIm5ld05hbWUiLCJkZWxldGVJRFJlY2lwZXRhYmxlIiwicmVjaXBlSWQiLCJpZCIsImVyck1lc3NhZ2UiLCJtZXNzYWdlRWxlbWVudCIsInN1Y2Nlc3MiLCJmZXRjaFRhYmxlRGF0YSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/api/scripts.js\n"));

/***/ })

});